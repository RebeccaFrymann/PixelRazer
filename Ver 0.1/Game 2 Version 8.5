from user303_hgosSqUFPG_1 import Vector
from user301_35na3iAwqQ_0 import RegularPolygon
from user303_OHTLTXLRlz_5 import Particle
import simplegui
import math, random

########
#Start story#
WIDTHs = 1366
HEIGHTs = 768
image_centers = (683, 384)
image_sizes = (1366, 768)
DIMs = [5, 8]
images = simplegui.load_image("https://imgur.com/BcOEwMz")

# Side (RIGHT) view of character #
RIGHT_WIDTH = 1000 / 4
RIGHT_HEIGHT = 500 / 2
RIGHT_CENTER = [RIGHT_WIDTH/2, RIGHT_HEIGHT/2]
RIGHT_SIZE = [RIGHT_WIDTH, RIGHT_HEIGHT]
RIGHT_DIM = [4, 2]
right_image = simplegui.load_image("https://i.imgur.com/caAvbvK.png")

# Side(LEFT) view of character#
LEFT_WIDTH = 1000/4
LEFT_HEIGHT = 500/2
LEFT_CENTER = [LEFT_WIDTH/2, LEFT_HEIGHT/2]
LEFT_SIZE = [LEFT_WIDTH, LEFT_HEIGHT]
LEFT_DIM = [4,2]
left_image = simplegui.load_image("https://i.imgur.com/WgnPT6V.png")

# Back view of character #
BACK_WIDTH = 1000/4
BACK_HEIGHT = 500/2
BACK_CENTER = [BACK_WIDTH/2, BACK_HEIGHT/2]
BACK_SIZE = [BACK_WIDTH, BACK_HEIGHT]
BACK_DIM = [4,2]
back_image = simplegui.load_image("https://i.imgur.com/nQW0p1G.png")

# Front view of character#
FRONT_WIDTH = 1000/4
FRONT_HEIGHT = 500/2
FRONT_CENTER = [FRONT_WIDTH/2, FRONT_HEIGHT/2]
FRONT_SIZE = [FRONT_WIDTH, FRONT_HEIGHT]
FRONT_DIM = [4,2]
front_image = simplegui.load_image("https://i.imgur.com/haAhGWE.png")

## Character attck ##
ATTACK_WIDTH = 1000/4
ATTACK_HEIGHT = 500/2
ATTACK_CENTER = [ATTACK_WIDTH/2, ATTACK_HEIGHT/2]
ATTACK_SIZE = [ATTACK_WIDTH, ATTACK_WIDTH]
ATTACK_DIM = [4,2]
attack_image = simplegui.load_image("https://i.imgur.com/1HBjEey.png")

#Wisp
WISP_WIDTH = 1000 / 4
WISP_HEIGHT = 500 / 2
WISP_CENTER = [WISP_WIDTH/2, WISP_HEIGHT/2]
WISP_SIZE = [WISP_WIDTH, WISP_HEIGHT]
WISP_DIM = [4, 1]
wisp_image = simplegui.load_image("https://i.imgur.com/wgXrWg9.png")

#wisp shoot
gun = RegularPolygon(2, Vector(490, 600), 10)
gun1 = RegularPolygon(2, Vector(90,563), 10)

# Background image (Shilling ground floor) #
WIDTH = 768
HEIGHT = 768
image_center = (384, 384)
image_size = (750, 750)
pos = [384, 384]
image = simplegui.load_image("https://i.imgur.com/bFyXh2P.png")

# load 81 frame sprite sheer for explosion - image generated by phaedy explosion generator, source is hasgraphics.com
EXPLOSION_CENTER = [50, 50]
EXPLOSION_SIZE = [100, 100]
EXPLOSION_DIM = [9, 9]
explosion_image = simplegui.load_image("http://commondatastorage.googleapis.com/codeskulptor-assets/explosion.hasgraphics.png")

# End game#
WIDTH1 = 768
HEIGHT1 = 768
image_center1 = (384, 384)
image_size1 = (750, 750)
pos1 = [384, 384]
image1 = simplegui.load_image("https://i.imgur.com/60FIPlE.png")

#Start Screen#
WIDTHS = 768
HEIGHTS = 768
image_centerS = (384, 384)
image_sizeS = (750, 750)
posS = [384, 384]
imageS = simplegui.load_image("https://i.imgur.com/gSyCRye.png")


#########
##global variables##
global timerR
#global lives
scores = 0
lives = 3
isAttack = False
start = False
end = False
playagain = False

##sounds##
soundS = simplegui.load_sound("https://jukehost.co.uk/api/audio/7f2efa9452ebc04e10b7b0bfc8250e9e7b5e4f55/83197f9945d")
soundS.set_volume(0.5)

def timer_handler(): 
    global counter
    counter = (counter + 1) % (RIGHT_DIM[0] * RIGHT_DIM[1])
    
def click(pos):
    pos = Vector(pos[0], pos[1])
    global end
    global playagain
    global start
    start = True
    if (pos.getX() > 494 and pos.getX() < 695):
        if (pos.getY() > 669 and pos.getY() < 734):
            end = True
    if (pos.getX() > 48 and pos.getX() < 251):
        if (pos.getY() > 673 and pos.getY() < 739):
            playagain = True
            start = False
            
timerR = simplegui.create_timer(100, timer_handler)

class Character:
    def __init__(self, pos, radius = 10):
        self.pos = pos
        self.vel = Vector()
        self.radius = max(radius, 10)
        self.border = 1
        self.right = False
        self.up = False
        self.down = False
        self.left = False
        self.space = False
        
    def keyDown(self, key):
        if key == simplegui.KEY_MAP['right']:
            self.right = True
            timerR.start()
        if key == simplegui.KEY_MAP['left']:
            self.left = True
            timerR.start()
        if key == simplegui.KEY_MAP['up']:
            self.up = True
            timerR.start()
        if key == simplegui.KEY_MAP['down']:
            self.down = True
            timerR.start()
        if key == simplegui.KEY_MAP['space']:
            self.space = True
            timerR.start()
            
    def keyUp(self, key):
        if key == simplegui.KEY_MAP['right']:
            self.right = False
            timerR.stop()
        if key == simplegui.KEY_MAP['left']:
            self.left = False
            timerR.stop()
        if key == simplegui.KEY_MAP['up']:
            self.up = False
            timerR.stop()
        if key == simplegui.KEY_MAP['down']:
            self.down = False
            timerR.stop()
        if key == simplegui.KEY_MAP['space']:
            self.space = False
            timerR.stop()
            
    def getAttack(self):
        return isAttack
            
    def move(self):
        allowed = False
        allR = False
        allL = False
        allU = True
        #print(self.character.pos.getX())
        #Obstacles - Stairs#
        if (self.pos.getY() >= 510):
            allowed = True
        #Obstacles - Right key#
        if (self.pos.getX() >= 426 or self.pos.getX() <= 210):
            allR = True

        elif (allowed):
            allR = True
            
        #Obstacles - Left key#
        if (self.pos.getX() <= 215 or self.pos.getX() >= 427):
            allL = True

        elif (allowed):
            allL = True

        #Obstacles - Up key#
        if (self.pos.getX() >= 215 and self.pos.getX() <= 426 and self.pos.getY() < 512):
            allU = False
            
        if (self.right and self.pos.getX() <= 675 and allR == True):
            self.vel.add(Vector(1.5,0))
        if (self.left and self.pos.getX() >= 86 and allL == True):
            self.vel.add(Vector(-1.5,0))
        if (self.up and self.pos.getY() >= 75 and allU == True):
            self.vel.add(Vector(0,-1.5))
        if self.down and self.pos.getY() <= 650:
            self.vel.add(Vector(0,1.5))
        if (self.space):
            isAttack = True

    def attack(self, canvas):
        attack_index = [counter % ATTACK_DIM[0], counter // ATTACK_DIM[0]]
        canvas.draw_image(attack_image,
                          [ATTACK_CENTER[0] + attack_index[0] * ATTACK_SIZE[0],
                           ATTACK_CENTER[1] + attack_index[1] * ATTACK_SIZE[1]],
                           ATTACK_SIZE, self.pos.getP(), ATTACK_SIZE)
        
    def walkRight(self, canvas):
        right_index = [counter% RIGHT_DIM[0], counter // RIGHT_DIM[0]]
        canvas.draw_image(right_image, 
                          [RIGHT_CENTER[0] + right_index[0] * RIGHT_SIZE[0], 
                           RIGHT_CENTER[1] + right_index[1] * RIGHT_SIZE[1]], 
                           RIGHT_SIZE, self.pos.getP(), RIGHT_SIZE)
    def walkFront(self, canvas):
        front_index = [counter % FRONT_DIM[0], counter // FRONT_DIM[0]]
        canvas.draw_image(front_image, 
                         [FRONT_CENTER[0] + front_index[0] * FRONT_SIZE[0], 
                          FRONT_CENTER[1] + front_index[1] * FRONT_SIZE[1]], 
                          FRONT_SIZE, self.pos.getP(), FRONT_SIZE)
    def walkBack(self, canvas):
        back_index = [counter % BACK_DIM[0], counter // BACK_DIM[0]]
        canvas.draw_image(back_image, 
                         [BACK_CENTER[0] + back_index[0] * BACK_SIZE[0], 
                          BACK_CENTER[1] + back_index[1] * BACK_SIZE[1]], 
                          BACK_SIZE, self.pos.getP(), BACK_SIZE)
        
    def walkLeft(self, canvas):
        left_index = [counter % LEFT_DIM[0], counter // LEFT_DIM[0]]
        canvas.draw_image(left_image,
                         [LEFT_CENTER[0] + left_index[0] * LEFT_SIZE[0],
                          LEFT_CENTER[1] + left_index[1] * LEFT_SIZE[1]],
                          LEFT_SIZE, self.pos.getP(), LEFT_SIZE)
    def draw(self, canvas):
        if ((not self.down) and (not self.up) and (not self.right) and (not self.left) and (not self.space)):
            front_index = [counter % FRONT_DIM[0], counter // FRONT_DIM[0]]
            canvas.draw_image(front_image, 
                             [FRONT_CENTER[0] + front_index[0] * FRONT_SIZE[0], 
                              FRONT_CENTER[1] + front_index[1] * FRONT_SIZE[1]], 
                              FRONT_SIZE, self.pos.getP(), FRONT_SIZE)
        if (self.up) and not self.space and not self.down:
            self.walkBack(canvas)
            
        if (self.down) and not self.space:
            self.walkFront(canvas)
            
        if self.right and not self.down and not self.up and not self.left and not self.space:
            self.walkRight(canvas)
        
        if self.left and not self.down and not self.up and not self.space:
            self.walkLeft(canvas)
        
        if self.space:
            self.attack(canvas)
            soundS.play()
            
    def update(self):
        self.pos.add(self.vel)
        self.vel.multiply(0.50)
                   
class Wisp:    
    def __init__(self, velRange=1, radius=20):        
        self.pos = Vector(random.randrange(0, WIDTH),
                          random.randrange(0, HEIGHT))
        self.vel = Vector(velRange * (random.random() - 0.5),
                          velRange * (random.random() - 0.5))
        self.radius = radius
        self.border = 1

    def outX(self):
        return (self.pos.x + self.radius < 0 or
                self.pos.x - self.radius > WIDTH)

    def outY(self):
        return (self.pos.y + self.radius < 0 or
                self.pos.y - self.radius > HEIGHT)

    def update(self):
        self.pos.add(self.vel)
        if self.outX():
            self.pos.x %= WIDTH
            if self.vel.x >= 0:
                self.pos.x -= self.radius
            else:
                self.pos.x += self.radius
        if self.outY():
            self.pos.y %= HEIGHT
            if self.vel.y >= 0:
                self.pos.y -= 2 * self.radius
            else:
                self.pos.y += 2 * self.radius

    def draw(self, canvas):
        wisp_index = [counter % WISP_DIM[0], counter // WISP_DIM[0]]
        canvas.draw_image(wisp_image, 
                        [WISP_CENTER[0] + wisp_index[0] * WISP_SIZE[0], 
                        WISP_CENTER[1] + wisp_index[1] * WISP_SIZE[1]], 
                        WISP_SIZE, self.pos.getP(), WISP_SIZE)
        
    def bounce(self, normal):
        self.vel.reflect(normal)

    def collides(self, other):
        if self == other:
            return False
        else:
            dis = (self.pos - other.pos).length()
            collisionDis = (self.radius + self.border) + (other.radius + other.border)
            return dis <= collisionDis

class UPair:
    def __init__(self, fst, snd):
        self.fst = fst
        self.snd = snd

    def __hash__(self):
        return hash(( min(hash(self.fst), hash(self.snd)),
                      max(hash(self.fst), hash(self.snd)) ))
        
    def __eq__(self, other):
        return ((self.fst == other.fst and self.snd == other.snd) or
                (self.fst == other.snd and self.snd == other.fst))
    
    def __ne__(self, other):
        return not self.__eq__(other) 

c = Character(Vector(130,80))

class BallSet():    
    def __init__(self, number, velRange):
        self.ballSet = set()
        for i in range(number):
            self.ballSet.add(Wisp(velRange))
        self.inCollision = set()
            
    def update(self):
        for b in self.ballSet:
            b.update()

        for b1 in self.ballSet:
            for b2 in self.ballSet:
                if b1.collides(b2):
                    if UPair(b1, b2) not in self.inCollision:
                        self.inCollision.add(UPair(b1, b2))
                        n = (b1.pos - b2.pos).normalize()
                        delta = n * (b1.vel - b2.vel).dot(n)
                        b1.vel.subtract(delta)
                        b2.vel.add(delta)
                else:
                    self.inCollision.discard(UPair(b1, b2))
    
    def cCollide(self, character):
        global lives
        global scores

        for b1 in self.ballSet:
            if b1.collides(c):
                print(c.getAttack())
                
                if(not c.space):
                    lives -= 1
                    scores -= 10
                    if UPair(b1, c) not in self.inCollision:
                        self.inCollision.add(UPair(b1, c))
                        n = (b1.pos - c.pos).normalize()
                        delta = n * ((b1.vel * 2) - c.vel).dot(n)
                        b1.vel.subtract(delta)
                        #c.vel.add(delta)
                    else:
                        self.inCollision.discard(UPair(b1, c))
                else:
                    scores += 100
                    b1.pos.x = random.randint(0, 768)
                    b1.pos.y = random.randint(0, 768)
                    b1.vel.x = random.uniform(0, 1)
                    b1.vel.y = random.uniform(0, 1)
                    
    def getLives(self):
        return lives
    
    def getScores(self):
        return scores
                    
    def draw(self, canvas):
        for b in self.ballSet:
            b.draw(canvas)

    def animate(self, canvas):
        self.update()
        self.draw(canvas)

bs = BallSet(5, 5)

class Game:
    def startscreen(canvas):
        canvas.draw_image(imageS, image_centerS, image_sizeS, posS, image_sizeS)
    
    def endscreen(canvas):
        canvas.draw_image(image1, image_center1, image_size1, pos1, image_size1)
        
    def explosion(canvas):
        global time
        explosion_index = [time % EXPLOSION_DIM[0], (time // EXPLOSION_DIM[0]) % EXPLOSION_DIM[1]]
        canvas.draw_image(explosion_image, 
                        [EXPLOSION_CENTER[0] + explosion_index[0] * EXPLOSION_SIZE[0], 
                         EXPLOSION_CENTER[1] + explosion_index[1] * EXPLOSION_SIZE[1]], 
                         EXPLOSION_SIZE, [c.pos.getX(), c.pos.getY()], EXPLOSION_SIZE)
        time += 1
        
    def runningGame(canvas):
        canvas.draw_image(image, image_center, image_size, pos, image_size)
        bs.cCollide(c)
        canvas.draw_text(str(int(lives)), [40,70], 10, "White")
        canvas.draw_text("Lives: ", [10, 70], 10, "White")
        canvas.draw_text(str(int(scores)), [40,90], 10, "White")
        canvas.draw_text("Scores: ", [10, 90], 10, "White")
        c.draw(canvas)
        c.update()
        c.move()
        bs.draw(canvas)
        bs.animate(canvas)
        bs.update()
    
    def reset():
        #global lives 
        #global scores
        #lives = 3
        #scores = 0
        playagain = False
        
    def draw(canvas):
        global lives, scores
        if (playagain == True):
            Game.reset()
            
        if (start == True):
            #scores = bs.getScores()
            #lives = bs.getLives()
            if (lives > 0):
                Game.runningGame(canvas)
            else:
                Game.endscreen(canvas)
                lives = 3
                scores = 0
                if (end == True):
                    frame.stop()
        else:
            Game.startscreen(canvas)
frame = simplegui.create_frame('GAME', WIDTH, HEIGHT)
frame.set_draw_handler(Game.draw)
frame.set_keydown_handler(c.keyDown)
frame.set_keyup_handler(c.keyUp)
frame.set_mouseclick_handler(click)
counter = 0

frame.start()
timerR.start()
